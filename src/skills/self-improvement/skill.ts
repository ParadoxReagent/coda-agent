/**
 * SelfImprovementSkill (4.2 + 4.3): Weekly Opus reflection and prompt evolution.
 *
 * Tools (all mainAgentOnly):
 *   - improvement_proposals_list: list pending/all proposals
 *   - improvement_proposal_decide: approve or reject a proposal (tier 3)
 *   - improvement_trigger_reflection: manually trigger a reflection cycle (tier 3)
 *   - prompt_rollback: roll back a prompt section to previous version (tier 3)
 *
 * Scheduled: weekly_reflection (Sunday 3 AM by default)
 */
import type { Skill, SkillToolDefinition } from "../base.js";
import type { SkillContext } from "../context.js";
import type { Database } from "../../db/index.js";
import type { Logger } from "../../utils/logger.js";
import type { MessageSender } from "../../core/message-sender.js";
import type { PromptManager } from "../../core/prompt-manager.js";
import type { AuditService } from "../../core/audit.js";
import { improvementProposals } from "../../db/schema.js";
import { eq, desc, inArray } from "drizzle-orm";
import { assembleReflectionInput, runReflection } from "./reflection.js";
import { assembleGapDetectionInput, runGapDetection } from "./gap-detection.js";
import type { ProposalCategory } from "./types.js";

export class SelfImprovementSkill implements Skill {
  readonly name = "self-improvement";
  readonly description = "Weekly AI self-reflection and prompt evolution system";
  readonly kind = "skill" as const;

  private db?: Database;
  private logger?: Logger;
  private messageSender?: MessageSender;
  private promptManager?: PromptManager;
  private auditService?: AuditService;
  private getSystemPromptSnapshot?: (userId: string) => Promise<string>;
  private getToolList?: () => string[];
  private getSkillList?: () => string[];
  private reflectionCron: string;
  private approvalChannel: string;
  private promptEvolutionEnabled: boolean;
  private opusLlm?: SkillContext["opusLlm"];
  private llm?: SkillContext["llm"];
  private gapDetectionEnabled: boolean;
  private gapDetectionCron: string;
  private fewShotService?: { harvest(): Promise<number> };

  constructor(config?: {
    reflection_cron?: string;
    approval_channel?: string;
    prompt_evolution_enabled?: boolean;
    gap_detection_enabled?: boolean;
    gap_detection_cron?: string;
  }) {
    this.reflectionCron = config?.reflection_cron ?? "0 3 * * 0";
    this.approvalChannel = config?.approval_channel ?? "discord";
    this.promptEvolutionEnabled = config?.prompt_evolution_enabled ?? false;
    this.gapDetectionEnabled = config?.gap_detection_enabled ?? true;
    this.gapDetectionCron = config?.gap_detection_cron ?? "0 2 1 * *";
  }

  setPromptManager(pm: PromptManager): void {
    this.promptManager = pm;
  }

  setAuditService(as: AuditService): void {
    this.auditService = as;
  }

  setSystemPromptGetter(fn: (userId: string) => Promise<string>): void {
    this.getSystemPromptSnapshot = fn;
  }

  setToolListGetter(fn: () => string[]): void {
    this.getToolList = fn;
  }

  setSkillListGetter(fn: () => string[]): void {
    this.getSkillList = fn;
  }

  setFewShotService(service: { harvest(): Promise<number> }): void {
    this.fewShotService = service;
  }

  getRequiredConfig(): string[] {
    return [];
  }

  getTools(): SkillToolDefinition[] {
    return [
      {
        name: "improvement_proposals_list",
        description: "List improvement proposals generated by the weekly reflection cycle.",
        input_schema: {
          type: "object" as const,
          properties: {
            status: {
              type: "string",
              enum: ["pending", "approved", "rejected", "applied", "rolled_back", "all"],
              description: "Filter by status (default: pending)",
            },
            limit: { type: "number", description: "Max results (default 20)" },
          },
        },
        mainAgentOnly: true,
        permissionTier: 0,
      },
      {
        name: "improvement_proposal_decide",
        description: "Approve or reject an improvement proposal. Approved prompt proposals are automatically applied.",
        input_schema: {
          type: "object" as const,
          properties: {
            proposal_id: { type: "string", description: "UUID of the proposal" },
            decision: {
              type: "string",
              enum: ["approved", "rejected"],
              description: "Your decision",
            },
            feedback: { type: "string", description: "Optional feedback or reason" },
          },
          required: ["proposal_id", "decision"],
        },
        mainAgentOnly: true,
        requiresConfirmation: true,
        permissionTier: 3,
      },
      {
        name: "improvement_trigger_reflection",
        description: "Manually trigger a weekly reflection cycle immediately (generates new proposals).",
        input_schema: {
          type: "object" as const,
          properties: {},
        },
        mainAgentOnly: true,
        requiresConfirmation: true,
        permissionTier: 3,
      },
      {
        name: "prompt_rollback",
        description: "Roll back a prompt section to its previous version.",
        input_schema: {
          type: "object" as const,
          properties: {
            section_name: { type: "string", description: "Name of the prompt section to roll back" },
          },
          required: ["section_name"],
        },
        mainAgentOnly: true,
        requiresConfirmation: true,
        permissionTier: 3,
      },
      {
        name: "gap_detection_trigger",
        description: "Manually trigger a monthly capability gap detection cycle (analyzes 30 days of audit data).",
        input_schema: {
          type: "object" as const,
          properties: {},
        },
        mainAgentOnly: true,
        requiresConfirmation: true,
        permissionTier: 3,
      },
      {
        name: "few_shot_harvest_trigger",
        description: "Manually trigger a few-shot pattern harvest from high-scoring recent interactions.",
        input_schema: {
          type: "object" as const,
          properties: {},
        },
        mainAgentOnly: true,
        requiresConfirmation: true,
        permissionTier: 3,
      },
    ];
  }

  async startup(ctx: SkillContext): Promise<void> {
    this.db = ctx.db;
    this.logger = ctx.logger;
    this.messageSender = ctx.messageSender;
    this.opusLlm = ctx.opusLlm;
    this.llm = ctx.llm;

    if (ctx.scheduler) {
      ctx.scheduler.registerTask({
        name: "weekly_reflection",
        cronExpression: this.reflectionCron,
        handler: async () => { await this.runWeeklyReflection(); },
        enabled: true,
        description: "Weekly Opus reflection cycle for self-improvement",
      });

      if (this.gapDetectionEnabled) {
        ctx.scheduler.registerTask({
          name: "monthly_gap_detection",
          cronExpression: this.gapDetectionCron,
          handler: async () => { await this.runMonthlyGapDetection(); },
          enabled: true,
          description: "Monthly capability gap detection using 30 days of audit data",
        });
      }
    }
  }

  async shutdown(): Promise<void> {}

  async execute(toolName: string, input: Record<string, unknown>): Promise<string> {
    switch (toolName) {
      case "improvement_proposals_list": return this.listProposals(input);
      case "improvement_proposal_decide": return this.decideProposal(input);
      case "improvement_trigger_reflection": return this.triggerReflection();
      case "prompt_rollback": return this.rollbackPrompt(input);
      case "gap_detection_trigger": return this.triggerGapDetection();
      case "few_shot_harvest_trigger": return this.triggerFewShotHarvest();
      default: return `Unknown tool: ${toolName}`;
    }
  }

  private async listProposals(input: Record<string, unknown>): Promise<string> {
    if (!this.db) return "Database not initialized";

    const status = (input.status as string) ?? "pending";
    const limit = Math.min((input.limit as number) ?? 20, 50);

    const statusFilter = status === "all"
      ? undefined
      : inArray(improvementProposals.status, [status]);

    const rows = await this.db
      .select()
      .from(improvementProposals)
      .where(statusFilter)
      .orderBy(desc(improvementProposals.createdAt))
      .limit(limit);

    const EXECUTOR_ELIGIBLE_CATEGORIES = new Set(["capability_gap", "failure_mode", "tool_usage", "routing"]);

    // Format as a readable table so the agent cannot omit the UUIDs when presenting to the user.
    const lines: string[] = [
      `Found ${rows.length} proposal(s) with status="${status}":`,
      "",
    ];
    for (const r of rows) {
      const executorEligible = EXECUTOR_ELIGIBLE_CATEGORIES.has(r.category);
      lines.push(
        `ID: ${r.id}`,
        `  Title:    [P${r.priority ?? "?"}] ${r.title}`,
        `  Category: ${r.category}${executorEligible ? " (executor-eligible)" : " (prompt/config â€” use decide tool only)"}`,
        `  Status:   ${r.status}`,
        `  Created:  ${r.createdAt.toISOString()}`,
        ""
      );
    }
    lines.push(
      "To approve a proposal: improvement_proposal_decide(proposal_id=<ID>, decision=\"approved\")",
      "Executor picks up: capability_gap, failure_mode, tool_usage, routing (status=approved only).",
    );

    return lines.join("\n");
  }

  private async decideProposal(input: Record<string, unknown>): Promise<string> {
    if (!this.db) return "Database not initialized";

    const proposalId = input.proposal_id as string;
    const decision = input.decision as "approved" | "rejected";
    const feedback = input.feedback as string | undefined;

    const [proposal] = await this.db
      .select()
      .from(improvementProposals)
      .where(eq(improvementProposals.id, proposalId))
      .limit(1);

    if (!proposal) return JSON.stringify({ error: "Proposal not found" });
    if (proposal.status !== "pending") {
      return JSON.stringify({ error: `Proposal is already ${proposal.status}` });
    }

    let finalStatus: string = decision;
    let appliedAt: Date | undefined;

    // Auto-apply approved prompt proposals if evolution is enabled
    if (decision === "approved" && proposal.category === "prompt" && this.promptEvolutionEnabled && this.promptManager) {
      try {
        if (proposal.proposedDiff && proposal.targetSection) {
          const version = await this.promptManager.createVersion(
            proposal.targetSection,
            proposal.proposedDiff,
            proposal.id
          );
          await this.promptManager.activateVersion(proposal.targetSection, version);
          finalStatus = "applied";
          appliedAt = new Date();
          this.logger?.info({ proposalId, section: proposal.targetSection, version }, "Prompt proposal applied");
        }
      } catch (err) {
        this.logger?.warn({ error: err, proposalId }, "Failed to apply prompt proposal");
      }
    }

    await this.db
      .update(improvementProposals)
      .set({
        status: finalStatus,
        userDecision: decision,
        userFeedback: feedback ?? null,
        appliedAt: appliedAt ?? null,
      })
      .where(eq(improvementProposals.id, proposalId));

    return JSON.stringify({
      success: true,
      proposal_id: proposalId,
      decision,
      status: finalStatus,
      message: decision === "approved"
        ? `Proposal approved${finalStatus === "applied" ? " and applied" : ""}.`
        : "Proposal rejected.",
    });
  }

  private async triggerReflection(): Promise<string> {
    try {
      const count = await this.runWeeklyReflection();
      return JSON.stringify({
        success: true,
        proposals_generated: count,
        message: `Reflection cycle complete. Generated ${count} proposals.`,
      });
    } catch (err) {
      return JSON.stringify({ error: `Reflection failed: ${err instanceof Error ? err.message : String(err)}` });
    }
  }

  private async rollbackPrompt(input: Record<string, unknown>): Promise<string> {
    if (!this.promptManager) return JSON.stringify({ error: "Prompt manager not configured" });

    const sectionName = input.section_name as string;
    const success = await this.promptManager.rollback(sectionName);

    return JSON.stringify({
      success,
      section_name: sectionName,
      message: success
        ? `Rolled back prompt section "${sectionName}" to previous version.`
        : `No previous version to roll back to for "${sectionName}".`,
    });
  }

  private async triggerGapDetection(): Promise<string> {
    try {
      const count = await this.runMonthlyGapDetection();
      return JSON.stringify({
        success: true,
        proposals_generated: count,
        message: `Gap detection cycle complete. Generated ${count} proposals.`,
      });
    } catch (err) {
      return JSON.stringify({ error: `Gap detection failed: ${err instanceof Error ? err.message : String(err)}` });
    }
  }

  private async triggerFewShotHarvest(): Promise<string> {
    if (!this.fewShotService) {
      return JSON.stringify({ error: "Few-shot service not configured" });
    }
    try {
      const count = await this.fewShotService.harvest();
      return JSON.stringify({
        success: true,
        patterns_harvested: count,
        message: `Few-shot harvest complete. Stored ${count} new patterns.`,
      });
    } catch (err) {
      return JSON.stringify({ error: `Few-shot harvest failed: ${err instanceof Error ? err.message : String(err)}` });
    }
  }

  /**
   * Run the monthly capability gap detection cycle.
   * Returns the number of proposals generated.
   */
  async runMonthlyGapDetection(): Promise<number> {
    if (!this.db || !this.auditService) {
      this.logger?.warn("Gap detection: db or auditService not available");
      return 0;
    }

    const effectiveLlm = this.opusLlm ?? this.llm;
    if (!effectiveLlm) {
      this.logger?.warn("Gap detection: no LLM available");
      return 0;
    }

    this.logger?.info("Starting monthly gap detection cycle");

    try {
      const skillList = this.getSkillList?.() ?? [];
      const toolList = this.getToolList?.() ?? [];

      const gapInput = await assembleGapDetectionInput(
        this.db,
        this.auditService,
        skillList,
        toolList,
        this.logger!
      );

      const proposals = await runGapDetection(gapInput, effectiveLlm, this.logger!);

      if (proposals.length === 0) {
        this.logger?.info("Gap detection produced no proposals");
        return 0;
      }

      const cycleId = gapInput.cycleId;
      await this.db.insert(improvementProposals).values(
        proposals.map(p => ({
          cycleId,
          category: "capability_gap" as ProposalCategory,
          title: p.title.slice(0, 500),
          description: p.description,
          proposedDiff: p.proposed_diff,
          targetSection: p.target_section,
          priority: Math.min(10, Math.max(1, Math.round(p.priority))),
          status: "pending",
          metadata: { source: "gap_detection" },
        }))
      );

      const summary = [
        `ðŸ” **Monthly Gap Detection Complete** (${proposals.length} proposals)`,
        "",
        ...proposals.map((p, i) =>
          `**${i + 1}. ${p.title}** (priority: ${p.priority})\n${p.description.slice(0, 150)}...`
        ),
        "",
        "Use `improvement_proposals_list` to review and act on these proposals.",
      ].join("\n");

      await this.messageSender?.send(this.approvalChannel, summary, "gap-detection");

      this.logger?.info({ proposalCount: proposals.length, cycleId }, "Gap detection cycle complete");
      return proposals.length;
    } catch (err) {
      this.logger?.error({ error: err }, "Gap detection failed");
      return 0;
    }
  }

  /**
   * Run the weekly Opus reflection cycle.
   * Returns the number of proposals generated.
   */
  async runWeeklyReflection(): Promise<number> {
    if (!this.db || !this.auditService) {
      this.logger?.warn("Self-improvement: db or auditService not available for reflection");
      return 0;
    }

    const effectiveLlm = this.opusLlm ?? this.llm;
    if (!effectiveLlm) {
      this.logger?.warn("Self-improvement: no LLM available for reflection");
      return 0;
    }

    this.logger?.info("Starting weekly reflection cycle");

    try {
      const systemPrompt = await this.getSystemPromptSnapshot?.("system") ?? "System prompt unavailable";
      const toolList = this.getToolList?.() ?? [];

      const input = await assembleReflectionInput(
        this.db,
        this.auditService,
        systemPrompt,
        toolList,
        this.logger!
      );

      const proposals = await runReflection(input, effectiveLlm, this.logger!);

      if (proposals.length === 0) {
        this.logger?.info("Reflection cycle produced no proposals");
        return 0;
      }

      // Insert proposals
      const cycleId = input.cycleId;
      const VALID_CATEGORIES = new Set(["prompt", "routing", "memory", "capability_gap", "failure_mode", "tool_usage"]);

      await this.db.insert(improvementProposals).values(
        proposals.map(p => ({
          cycleId,
          category: (VALID_CATEGORIES.has(p.category) ? p.category : "capability_gap") as ProposalCategory,
          title: p.title.slice(0, 500),
          description: p.description,
          proposedDiff: p.proposed_diff,
          targetSection: p.target_section,
          priority: Math.min(10, Math.max(1, Math.round(p.priority))),
          status: "pending",
          metadata: {},
        }))
      );

      // Send summary to approval channel
      const summary = [
        `ðŸ“Š **Weekly Reflection Complete** (${proposals.length} proposals)`,
        "",
        ...proposals.slice(0, 5).map((p, i) =>
          `**${i + 1}. [${p.category}] ${p.title}** (priority: ${p.priority})\n${p.description.slice(0, 150)}...`
        ),
        "",
        "Use `improvement_proposals_list` to see all proposals and `improvement_proposal_decide` to act on them.",
      ].join("\n");

      await this.messageSender?.send(this.approvalChannel, summary, "self-improvement");

      this.logger?.info({ proposalCount: proposals.length, cycleId }, "Reflection cycle complete");
      return proposals.length;
    } catch (err) {
      this.logger?.error({ error: err }, "Weekly reflection failed");
      return 0;
    }
  }
}
